digraph gph {Cachev [label="package:collapsar \l file:cache.go \l struct:Cache \l ---------- \l storageList:[]StorageInterface\lcalculator:HashInterface\lclearIndex:int\loffset:uint32\llength:int\l", shape="box"];
Optionv [label="package:collapsar \l file:option.go \l struct:Option \l ---------- \l Length:int\lCalculator:HashInterface\lFailHandler:FailHandlerFunc\lRemoveHandler:RemoveHandlerFunc\lEliminateHandler:policy.EliminateInterface\l", shape="box"];
Itemv [label="package:collapsar \l file:storage.go \l struct:Item \l ---------- \l ttl:int64\lkey:string\lvalue:interface{}\lnext:*Item\l", shape="box"];
Nodev [label="package:collapsar \l file:storage.go \l struct:Node \l ---------- \l failHandler:FailHandlerFunc\lremoveHandler:RemoveHandlerFunc\llocker:sync.RWMutex\lavailItems:*Item\litems:map[string]*Item\leliminate:policy.EliminateInterface\l", shape="box"];
AdlerHashv [label="package:hash \l file:adler_hash.go \l struct:AdlerHash \l ---------- \l ", shape="box"];
LFUEliminatev [label="package:policy \l file:LFU.go \l struct:LFUEliminate \l ---------- \l eliminateRate:float32\lmaxNumber:int\lcontainer:*EliminateContainer\l", shape="box"];
EliminateContainerv [label="package:policy \l file:eliminate_container.go \l struct:EliminateContainer \l ---------- \l shortTermContainer:sync.Map\llongTermContainer:sync.Map\l", shape="box"];
LRUEliminatev [label="package:policy \l file:LRU.go \l struct:LRUEliminate \l ---------- \l container:*EliminateContainer\leliminateRate:float32\lmaxNumber:int\l", shape="box"];
Entryv [label="package:policy \l file:eliminate_container.go \l struct:Entry \l ---------- \l key:string\lvalue:int64\l", shape="box"];
Itemv->Itemv;
Nodev->Itemv;
LFUEliminatev->EliminateContainerv;
LRUEliminatev->EliminateContainerv;
}